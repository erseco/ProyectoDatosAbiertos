\chapter{Desarrollo}

Una vez tenemos la ontología completamente diseñada (cuya versión completa se puede encontrar en el \textbf{Anexo I)}, el trabajo restante se divide en dos tareas:

\begin{itemize}
	\item Convertir los datos a un formato triple {\sf RDF} que siga la ontología que hemos diseñado.
	\item Crear la infraestructura necesaria para disponer de un punto de acceso a la información.
\end{itemize}

\section{Conversión de los datos}

Todos los datos están en archivos en formato {\sf CSV} (disponibles en el servidor C{\sf KAN} de {\sf OpenData UGR}) siguiendo la misma estructura: la primera fila representa el título del dato y el resto los valores. Para resolver esto la opción más sencilla es desarrollar scripts que nos permitan procesar los archivos originales, aunque se podría hacer en varios lenguajes, se ha elegido {\sf Python} por ser con el que se está más familiarizado para este tipo de tareas.

\bigskip
El procedimiento consistiría en cargar el archivo con los datos, y después de escribir en el archivo de destino las cabeceras con las definiciones de los espacios de nombres, ir añadiendo cada uno de los datos con el formato necesitado. La forma esquemática sería la siguiente: 

\newpage
\begin{listing}[!ht]
\begin{minted}{python}
import csv

id = 0

with open('ORIGEN.csv', 'r') as ifile:
    reader = csv.reader(ifile)
    data = list(reader)

ofile = open('DESTINO.rdf', 'w')
ofile.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"+
"<rdf:RDF\n"+
"\txmlns=\"http://cabas.ugr.es/resources/\"\n"+
"\txmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n"+
"\txmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\n"+
"\txmlns:xsd=\"http://www.w3.org/2001/XMLSchema#\"\n"+
"\txmlns:owl=\"http://www.w3.org/2002/07/owl#\"\n"+
"\txmlns:dcterms=\"http://purl.org/dc/terms/\"\n"+
"\txmlns:ugr=\"http://cabas.ugr.es/ontology/ugr#\">\n\n")
ofile.close()

with open('DESTINO.rdf', 'a') as ofile:
    for lines in data:
        if id > 0:
            ofile.write("<rdf:Description rdf:about=\"CLASE#"+
            str(id)+"\">\n"+
            "\t<rdfs:label>"+lines[1]+"</rdfs:label>\n"+
            "\t<ugr:PROPIEDAD_1>"+lines[0]+"</ugr:PROPIEDAD_1>\n"+
            "\t<ugr:PROPIEDAD_2>"+lines[1]+"</ugr:PROPIEDAD_2>\n"+
            "\t<ugr:PROPIEDAD_n>"+lines[n-1]+"</ugr:PROPIEDAD_n>\n"+
            "</rdf:Description>\n\n")
        id += 1

ofile = open('DESTINO.rdf', 'a')
ofile.write("</rdf:RDF>")
ofile.close()
\end{minted}
\caption{Plantilla script procesamiento archivos CSV}
\end{listing}

\newpage
\section{Infraestructura para el punto de acceso SPARQL}

La infraestructura que necesitaremos para tener el punto consta de dos partes: 

\begin{itemize}
	\item Un servidor web con acceso público desde {\sf Internet} cuya dirección será el {\sf URI} que identifique a nuestra ontología y los recursos que la utilizan, ya que todos los archivos serán servidos por dicho servidor. En este caso utilizaremos el servidor web {\sf Nginx}.
	\item El propio punto de acceso {\sf SPARQL},  para el que necesitaremos un servidor que permita almacenar los recursos en formato {\sf RDF/XML} que hemos generado y sobre esa misma información realizar las consultas. Para esto utilizaremos el servidor {\sf ORDBMS} {\sf Virtuoso}, montando sistemas de pruebas que correrán en máquinas virtuales {\sf Vagrant} que configuraremos automáticamente con {\sf Ansible}.
\end{itemize}

\subsection{Servidor web}

Tenemos que configurar nuestro servidor {\sf NGINX} para que realice las siguiente acciones:

\begin{itemize}
	\item Sirva los archivos de la ontología y los recursos en formato {\sf RDF/XML}.
	\item Resuelva los {\sf URIs} de la ontología y los recursos en formato {\sf RDF/XML}.
	\item Aplique el tipo {\sf MIME} {\tt application/rdf+xml} cuando devuelva archivos con extensión {\tt rdf} y el tipo {\tt text/turtle} cuando devuelva archivos con extensión {\tt ttl}.
\end{itemize}

Como mencionábamos en el capítulo de planificación, todos los servidores de los que vamos a hacer uso (tanto para pruebas como para despliegue final) tienen un sistema operativo {\bf Ubuntu}, así que este es el sistema que se tomará como referencia para todas las configuraciones. Para la configuración que queremos establecer, fundamentalmente tendremos que editar tres archivos de la configuración de {\bf NGINX}.

\begin{itemize}
	\item {\tt nginx.conf}: es el archivo de configuración principal de {\bf NGINX}.
	\item {\tt sites-availables} / {\tt sites-enabled}: son los directorios donde se encuentran los archivos de configuración de los {\bf hosts virtuales}. Un host virtual es configuración usada para tener varios sitios web en un único ser compartiendo la misma IP, generalmente siendo redireccionados en función de un nombre.
	\item {\tt mime.types}: es el archivo que nos permite configurar la respuesta de nuestro servidor ante las peticiones de diferentes tipos de archivos.
\end{itemize}

\subsubsection{nginx.conf}

El archivo {\tt nginx.conf} se divide en varias secciones, en nuestro caso particular la sección que nos interesa es la que se refiere al contexto en el que se especifican las directivas del {\bf servidor HTTP}, la sección {\tt http}; concretamente, lo que queremos es poder cargar archivos de configuración de host virtuales desde el directorio {\tt sites-enabled} lo que podemos conseguir mediante la directiva {\tt include}.
\bigskip

\begin{listing}[!ht]
\begin{minted}{bash}
user  nginx;
...

http {
...

    include sites-enabled/*;
}
\end{minted}
\caption{Archivo de configuración de {\bf NGINX}}
\end{listing}

\subsubsection{sites-availables}

Como la configuración de host virtual que necesitamos es muy básica, podemos usar el propio archivo de host virtual que viene por defecto, lo que tendremos que añadir es una ubicación para el {\tt URI} de la ontología, una ubicación para el {\tt URI} de cada uno de los recursos, una ubicación para la ruta de acceso al directorio con los archivos de la ontología en diferentes formatos y una ubicación para la ruta de acceso al directorio con los archivos de los recursos en diferentes formatos. Es importante tener en cuenta que con la directiva {\tt root} se indica la ruta que se toma como base de la estructura de la archivos que estarán disponibles.

\bigskip
\begin{listing}[!ht]
\begin{minted}{bash}
server {
...

    root /var/www/html;
	
    location /ontology/ {
        try_files $uri $uri/ =404;
        autoindex on;
    }
	
    location /ontology/ugr {
        rewrite ^/ontology/ugr$ /ontology/ugr.ttl;
    }

    location /resources/ {
        try_files $uri $uri/ =404;
        autoindex on;
    }

    location /resources/CLASE {
        rewrite ^/resources/CLASE$ /ontology/CLASE.ttl;
    }
}
\end{minted}
\caption{Archivo de configuración del {\bf host virtual} por defecto}
\end{listing}

\subsubsection{mimes.type}

Lo único que nos queda por configurar de nuestro servidor web es el tipo de respuesta que va a dar cuando se le haga la petición de un archivo con extensión {\tt .rdf} {formato {\tt RDF/XML} o extensión {\tt .ttl} {formato {\tt Terse RDF Triple Language}, ya que en caso de no especificarlo, al ser extensiones desconocidas para nuestro servidor los devolverá como tipo texto, lo que puede provocar problemas a la hora de realizar las peticiones de nuestro punto de acceso {\bf SPARQL}.

\bigskip
\begin{listing}[!ht]
\begin{minted}{bash}
types {
...

    application/rdf+xml    rdf;
    text/turtle    ttl;
}
\end{minted}
\caption{Archivo de configuración de tipos {\bf MIME}}
\end{listing}

\newpage
\
\newpage
\subsection{Punto de acceso SPARQL}

El software que vamos a usar para proveer de un punto de acceso {\bf SPARQL} ya hemos comentado que será {\bf Openlink Virtuoso}; aunque existen muchas soluciones, unas más sencillas ({\bf Stardog}\footnote{\url{http://www.stardog.com/}}, {\bf Blazegraph}\footnote{\url{https://www.blazegraph.com/}}, {\bf RDF4J}{\footnote{\url{http://rdf4j.org/}}}) y otras de una complejidad similar ({\bf Apache Jena}{\footnote{\url{https://jena.apache.org/}}}, {\bf 4Store}\footnote{\url{https://github.com/4store/4store}}), ninguna tiene las capacidades de almacenamiento de datos, gestión de base de datos y provisión de punto {\bf SPARQL} que tiene Virtuoso, esto es lo que ha hecho que su uso sea tan extendido en proyectos de dimensiones considerables, como el que ya hemos mencionado en varias ocasiones que es {\bf DBpedia}.

\bigskip
Debido a que Virtuoso es un software algo pesado, las pruebas se realizaran sobre máquinas virtuales de prueba. Estos servidores virtuales los crearemos con {\bf Vagrant}, una herramienta para la creación y configuración de entornos de desarrollo virtualizados que se monta como una capa de abstracción sobre máquinas virtuales creadas con el software de virtualización {\bf VirtualBox} (en nuestro caso particular, ya que es compatible con otros sistemas de virtualización como {\bf VMware\footnote{\url{https://www.vmware.com/es.html}}} o {\bf Amazon EC2\footnote{\url{https://aws.amazon.com/es/ec2/}}}). Además, estos entornos de desarrollo serán configurados automáticamente con {\bf Ansible}, un software que se encarga de configurar y administrar sistemas de forma automática según especifiquemos en un {\bf playbook}, que es el nombre que reciben sus archivos de configuración.

\bigskip
Los archivos de configuración de las máquinas {\bf Vagrant} permiten indicar una gran cantidades de especificaciones de la propia máquina, pero en nuestro caso solo tenemos dos propiedades imprescindibles: la dirección de red privada mediante a la cual nos conectaremos internamente a la máquina virtual y el puerto redireccionado que nos permitirá realizar peticiones al puerto de la máquina virtual del que {\bf Virtuoso} escucha las peticiones desde nuestro sistema anfitrión. Aunque {\bf Vagrant} nos ejecutar de forma automática {\bf playbooks} de {\bf Ansible}, por ahora esto lo vamos a hacer manualmente hasta que sepamos que todo funciona correctamente.

\begin{listing}[!ht]
\begin{minted}{ruby}
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure(2) do |config|
    config.vm.box = "ubuntu/xenial64"
    config.vm.hostname = "virtuoso"
    
    config.vm.network "forwarded_port", guest: 8890, host: 8890
    config.vm.network "private_network", ip: "192.168.33.20"

    config.vm.provider "virtualbox" do |v|
        v.memory = 2048
        v.cpus = 1
        v.name = config.vm.hostname.to_s
    end

end
\end{minted}
\caption{Vagrantfile del sistema de prueba de Virtuoso}
\end{listing}

\newpage
Cuando comprobemos que nuestro sistema de pruebas funciona correctamente, lo siguiente sería mediante {\bf Ansible} instalar en él de forma automática todo lo necesario para tener Virtuoso funcionando. En el \hyperref[anexo_v]{Anexo V} tenemos la configuración completa para instalar {\bf Virtuoso} mediante {\bf Ansible}. Para comprobar que {\bf Virtuoso} está funcionando correctamente deberíamos acceder a la dirección de la máquina virtual y el puerto que escucha {\bf Virtuoso}: \url{http://192.168.33.20:8890/}. Con Virtuoso funcionando, lo siguiente será proceder con la carga de datos.

\bigskip
Aunque podemos cargar los datos desde la interfaz web, deberíamos hacerlo uno por uno, lo que es sería un trabajo laborioso. Para estas situaciones la mejor opción es usar la carga masiva de recursos, esta opción nos permite cargar desde terminal todos los archivos en una ubicación de una vez.